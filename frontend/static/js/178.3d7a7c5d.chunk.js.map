{"version":3,"file":"static/js/178.3d7a7c5d.chunk.js","mappings":"gNAgBO,MAAMA,EAA8BC,UACzC,IAAK,IAADC,EAAAC,EACFC,QAAQC,IAAI,yEACZD,QAAQC,IAAI,8CAAqCC,GACjDF,QAAQC,IAAI,yCAAgC,GAAGE,EAAAA,EAAWC,mCAAmCF,KAE7F,MAAMG,QAAiBC,MAAM,GAAGH,EAAAA,EAAWC,mCAAmCF,KAE9E,IAAKG,EAASE,GAEZ,OADAP,QAAQQ,KAAK,oEAA2DH,EAASI,QAC1E,KAGT,MAAMC,QAAaL,EAASM,OAG5B,GAFAX,QAAQC,IAAI,kDAAyCS,IAEhDA,EAAKE,aAER,OADAZ,QAAQQ,KAAK,wEACN,KAGTR,QAAQC,IAAI,uDAA8CS,EAAKE,cAG/D,MAQMC,EARwB,CAC5B,KAAQ,EACR,KAAQ,EACR,IAAO,GACP,WAAc,KAG2B,QAA7Bf,EAAGY,EAAKE,aAAaE,gBAAQ,IAAAhB,OAAA,EAA1BA,EAA4BiB,gBACcL,EAAKE,aAAaI,kBAEvEC,EAAUP,EAAKE,aAAaK,SAAW,EACvCC,EAAUR,EAAKE,aAAaM,SAAW,EAEvCC,EAAW,IACZT,EAAKE,aACRI,kBAAmBH,EAEnBI,QAASA,EACTC,QAASA,EACTJ,SAAUJ,EAAKE,aAAaE,SAC5BM,SAAUV,EAAKE,aAAaQ,SAC5BC,UAAyC,IAA/BX,EAAKE,aAAaS,SAC5BC,YAA6C,IAAjCZ,EAAKE,aAAaU,WAE9BC,iBAAkBb,EAAKE,aAAaW,kBAAoBb,EAAKE,aAAaY,UAAY,GACtFA,SAAUd,EAAKE,aAAaW,kBAAoBb,EAAKE,aAAaY,UAAY,GAE9EC,iBAAkBC,KAAKC,IAAI,EAAGd,EAAkBI,GAChDW,aAAcF,KAAKC,IAAI,EAAGT,GAC1BW,eAAgBhB,GAgBlB,OAbAb,QAAQC,IAAI,wDAAoD,CAC9Da,SAAUK,EAASL,SACnBG,QAASE,EAASF,QAClBY,eAAgBV,EAASH,kBACzBE,QAASC,EAASD,QAClBO,iBAAkBN,EAASM,iBAC3BG,aAAcT,EAASS,aACvBL,iBAAkBJ,EAASI,iBAC3BO,eAAwC,QAAzB/B,EAAAoB,EAASI,wBAAgB,IAAAxB,OAAA,EAAzBA,EAA2BgC,SAAU,IAGtD/B,QAAQC,IAAI,0DAAiDkB,GAEtDA,CAET,CAAE,MAAOa,GAEP,OADAhC,QAAQgC,MAAM,6DAAyDA,GAChE,IACT,GAQWC,EAA6BpC,UACxC,IACE,MAAMsB,QAAiBvB,EAA4BM,GAEnD,IAAKiB,EACH,MAAO,CACLe,YAAY,EACZC,OAAQ,qBACRlB,QAAS,EACTY,eAAgB,EAChBX,QAAS,GAIb,MAAMD,EAAUE,EAASF,SAAW,EAC9BY,EAAiBV,EAASH,mBAAqB,EAC/CoB,EAAajB,EAASD,SAAW,EAGjCmB,EAAsBpB,GAAWY,EACjCS,EAAoBF,GAAc,EAElCF,GAAcG,IAAwBC,EAW5C,OATAtC,QAAQC,IAAI,wDAA+C,CACzDgB,UACAY,iBACAO,aACAC,sBACAC,oBACAJ,eAGK,CACLA,aACAC,OAAQE,EAAsB,wBACtBC,EAAoB,wBAA0B,KACtDrB,UACAY,iBACAX,QAASkB,EACTX,iBAAkBC,KAAKC,IAAI,EAAGE,EAAiBZ,GAGnD,CAAE,MAAOe,GAEP,OADAhC,QAAQgC,MAAM,+DAA2DA,GAClE,CACLE,YAAY,EACZC,OAAQ,uBACRlB,QAAS,EACTY,eAAgB,EAChBX,QAAS,EAEb,E","sources":["utils/planDataHelpers.js"],"sourcesContent":["/**\n * Plan Data Helpers - Single Source of Truth\n * \n * This utility provides functions to fetch plan/subscription data\n * from the PlanSelectionDetails collection via the get-user-profile endpoint.\n * \n * This ensures consistency between UI and backend quota checks.\n */\n\nimport { ENV_CONFIG } from './environmentConfig';\n\n/**\n * Fetch plan/subscription data from single source of truth (PlanSelectionDetails)\n * @param {string} userId - User ID\n * @returns {Promise<Object|null>} Plan data or null if not found\n */\nexport const getPlanDataFromSingleSource = async (userId) => {\n  try {\n    console.log('üîç PlanDataHelper - Fetching from single source of truth...');\n    console.log('üîç PlanDataHelper - Using userId:', userId);\n    console.log('üîç PlanDataHelper - API URL:', `${ENV_CONFIG.PYTHON_API_URL}/get-user-profile/${userId}`);\n    \n    const response = await fetch(`${ENV_CONFIG.PYTHON_API_URL}/get-user-profile/${userId}`);\n    \n    if (!response.ok) {\n      console.warn('‚ö†Ô∏è PlanDataHelper - Failed to fetch from single source:', response.status);\n      return null;\n    }\n    \n    const data = await response.json();\n    console.log('üîç PlanDataHelper - Raw API response:', data);\n    \n    if (!data.subscription) {\n      console.warn('‚ö†Ô∏è PlanDataHelper - No subscription data found in response');\n      return null;\n    }\n    \n    console.log('üîç PlanDataHelper - Raw subscription data:', data.subscription);\n    \n    // Fix for incorrect max_ads_per_month values - validate against plan type\n    const correctMaxAdsPerMonth = {\n      'lite': 4,\n      'plus': 5, \n      'pro': 11,\n      'enterprise': 999\n    };\n    \n    const planType = data.subscription.planType?.toLowerCase();\n    const correctedMaxAds = correctMaxAdsPerMonth[planType] || data.subscription.max_ads_per_month;\n    \n    const adsUsed = data.subscription.adsUsed || 0;\n    const adQuota = data.subscription.adQuota || 0;\n    \n    const planData = {\n      ...data.subscription,\n      max_ads_per_month: correctedMaxAds,\n      // Ensure consistent field names\n      adsUsed: adsUsed,\n      adQuota: adQuota,\n      planType: data.subscription.planType,\n      planName: data.subscription.planName,\n      isActive: data.subscription.isActive !== false,\n      subscribed: data.subscription.subscribed !== false,\n      // **FIX**: Include selectedFeatures from subscription data\n      selectedFeatures: data.subscription.selectedFeatures || data.subscription.features || [],\n      features: data.subscription.selectedFeatures || data.subscription.features || [],\n      // Add calculated fields that the UI expects\n      monthlyRemaining: Math.max(0, correctedMaxAds - adsUsed),\n      remainingAds: Math.max(0, adQuota),\n      maxAdsPerMonth: correctedMaxAds // Alternative field name\n    };\n    \n    console.log('‚úÖ PlanDataHelper - Plan data from single source:', {\n      planType: planData.planType,\n      adsUsed: planData.adsUsed,\n      maxAdsPerMonth: planData.max_ads_per_month,\n      adQuota: planData.adQuota,\n      monthlyRemaining: planData.monthlyRemaining,\n      remainingAds: planData.remainingAds,\n      selectedFeatures: planData.selectedFeatures,\n      featuresCount: planData.selectedFeatures?.length || 0\n    });\n    \n    console.log('üîç PlanDataHelper - FULL processed plan data:', planData);\n    \n    return planData;\n    \n  } catch (error) {\n    console.error('‚ùå PlanDataHelper - Error fetching from single source:', error);\n    return null;\n  }\n};\n\n/**\n * Check if user can analyze more ads based on single source data\n * @param {string} userId - User ID\n * @returns {Promise<Object>} Quota status with canAnalyze flag\n */\nexport const checkQuotaFromSingleSource = async (userId) => {\n  try {\n    const planData = await getPlanDataFromSingleSource(userId);\n    \n    if (!planData) {\n      return {\n        canAnalyze: false,\n        reason: 'No plan data found',\n        adsUsed: 0,\n        maxAdsPerMonth: 0,\n        adQuota: 0\n      };\n    }\n    \n    const adsUsed = planData.adsUsed || 0;\n    const maxAdsPerMonth = planData.max_ads_per_month || 0;\n    const totalQuota = planData.adQuota || 0;\n    \n    // Check both monthly and total limits\n    const monthlyLimitReached = adsUsed >= maxAdsPerMonth;\n    const totalLimitReached = totalQuota <= 0;\n    \n    const canAnalyze = !monthlyLimitReached && !totalLimitReached;\n    \n    console.log('üîç QuotaCheck - Single source quota status:', {\n      adsUsed,\n      maxAdsPerMonth,\n      totalQuota,\n      monthlyLimitReached,\n      totalLimitReached,\n      canAnalyze\n    });\n    \n    return {\n      canAnalyze,\n      reason: monthlyLimitReached ? 'Monthly limit reached' : \n              totalLimitReached ? 'Total quota exhausted' : 'OK',\n      adsUsed,\n      maxAdsPerMonth,\n      adQuota: totalQuota,\n      monthlyRemaining: Math.max(0, maxAdsPerMonth - adsUsed)\n    };\n    \n  } catch (error) {\n    console.error('‚ùå QuotaCheck - Error checking quota from single source:', error);\n    return {\n      canAnalyze: false,\n      reason: 'Error checking quota',\n      adsUsed: 0,\n      maxAdsPerMonth: 0,\n      adQuota: 0\n    };\n  }\n};\n"],"names":["getPlanDataFromSingleSource","async","_data$subscription$pl","_planData$selectedFea","console","log","userId","ENV_CONFIG","PYTHON_API_URL","response","fetch","ok","warn","status","data","json","subscription","correctedMaxAds","planType","toLowerCase","max_ads_per_month","adsUsed","adQuota","planData","planName","isActive","subscribed","selectedFeatures","features","monthlyRemaining","Math","max","remainingAds","maxAdsPerMonth","featuresCount","length","error","checkQuotaFromSingleSource","canAnalyze","reason","totalQuota","monthlyLimitReached","totalLimitReached"],"sourceRoot":""}